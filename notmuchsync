#!/usr/bin/env python
"""
    (c) 2010 Sebastian Spaeth Sebastian@SSpaeth.de
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2.1 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import subprocess, re, logging, os, sys, time

#---------------------------------------------------------------------------
class Message:
#---------------------------------------------------------------------------
    """
    Represents a message as returned by notmuch. Do note that the parsing 
    approch is pretty hackish, but we have to wait for notmuch to return 
    output in a nicer format.

    - Valid instance variables self.*:
      The following vars are set on the initial parsing:
      .id (msg id, is set on the initial parsing)
      .file (full file name including path, is set on the initial parsing)
      .tags: a set() of MailDir flags
      .notmuchtags: a set() of notmuch tags

      If the following two variables contain a set() of tags/flags that are 
      different from .tags .notmuchtags, a sync_msg_tags will write those 
      changes:
      .sync_tags: a set() of MailDir flags to be used
      .sync_notmuchtags: a set() of notmuch tags to be used

      .valid: is True if parsing found a message, False otherwise
    """

    msg_parts = re.compile(r'\x0cmessage\}\s*\x0cmessage\{',re.S)
    msg_meta  = re.compile(r'(\x0cmessage\{)?\s*id:(?P<id>\S+)\s+(.*)filename:(?P<file>.*(:[12],(?P<tags>[A-Z]*)))\n\x0cheader{\n([^\n]*)\((?P<notmuchtags>[\w ]*)\)\n.*\x0cheader}',re.S)

    def __init__(self, nm_msg):
       """inititialize a message from "nm_msg" (output from notmuch show 
       which has the \x0cmessage{...\x0cmessage} stripped.
       """
       self.valid=False
       self.tags = self.sync_tags = None
       self.notmuchtags = self.sync_notmuchtags = None
       self.parse(nm_msg)

    def parse(self, message):
       m = Message.msg_meta.match(message)
       if m != None:
           self.valid=True
           self.id = m.group('id')
           self.file = m.group('file')
           self.tags = set(m.group('tags'))
           self.notmuchtags = set(m.group('notmuchtags').split())
       else:
           #TODO better output here
           logging.warning("no valid mail")

    def __repr__(self):
        """A message is represented by "id:blah" (if valid) or 'NULL' """
        if not self.valid or hasattr(self,"id") == True:
            return "NULL"
        return "id:%s" % (self.id)

    def sync_msg_tags(self, dryrun=False):
        """ Sync up changed maildir tags and/or notmuch tags.
        It examines self.tags|sync_tags and self.notmuchtags|sync_notmuchtags
        sync_* contains the new set of tags to be applied
        """

        notmuch = Notmuch()

        if (self.sync_tags is not None and self.tags ^ self.sync_tags):
            #sync_tags differs from tags. Need to sync up maildir tags
            newtags = "".join(sorted(self.sync_tags))
            newfile = re.sub(r'^(.*:[12],)([A-Z]*)$',"\\1"+newtags,self.file)
            logging.debug("Change maildir flags on %s from %s to '%s'" % (self.file,sorted(self.tags),newtags))
            if not dryrun:
                try:
                    os.rename(self.file, newfile)
                except OSError, e:
                    if e.errno == 2:
                        logging.info("Renaming not possible, file %s not found" % (self.file))
                    else:
                        raise OSError(e)

        if (self.sync_notmuchtags is not None 
            and self.notmuchtags ^ self.sync_notmuchtags):
            #sync_notmuchtags differs. Need to sync notmuch tags
            #list of tags to delete and add e.g. ("-inbox -unread")
            remove = " ".join(map(lambda x:"-"+x,self.notmuchtags - self.sync_notmuchtags))
            add    = " ".join(map(lambda x:"+"+x,self.sync_notmuchtags - self.notmuchtags))

            logging.debug("Sync tag %s %s for id:%s" % (remove, add, self.id))

            if not dryrun:
                #actually modify the notmuch tag database
                prosses = notmuch.exec_cmd(["tag",remove, add, 
                                  "-- id:%s" % (self.id),])
                (stdout, stderr) = prosses.communicate()
                if stderr:
                    log.error(stderr)

#---------------------------------------------------------------------------
class Messages:
#---------------------------------------------------------------------------
    """
    An iterator containing a bunch of mail messages.
    """

    msg_part = re.compile(r'\s*\x0cmessage\}\s*\x0cmessage\{',re.S)
    msg_start = re.compile(r'\s*\x0cmessage\{')

    def __init__(self, nm_messages):
        """ Initialize Message with nm_messages (output from notmuch show) """
        self.msgs=[]
        if (nm_messages == None):
            #init an empty Messages
            return
        self.parse(nm_messages)

    def parse(self, nm_messages):
        """ parses nm_messages (output from notmuch show) and adds those
        Message()s to a self.msgs list.
        Returns None if no message was found. True otherwise
        """
        #split into one item per message
        m = Messages.msg_part.split(nm_messages)
        if m == None:
            #TODO:
            logging.warning("Found no valid messages")
            return None

        #we have trimmed of '\12message}' already, now trim the start
        m = map(lambda x: Messages.msg_start.sub('',x), m)

        #parse each single message and append it
        for msg in m:
            msg = Message(msg)
            if msg.valid:
                self.msgs.append(msg)

    def __len__(self):
        """ Returns the number of contained messages """
        return len(self.msgs)

    def __iter__(self):
        #Just return self
        self._iter_pos = 0
        return self

    def next(self):
        """ returns the next message when iterating """
        if (self._iter_pos == len(self.msgs)):
            raise StopIteration     # end of iteration
        self._iter_pos += 1
        return self.msgs[self._iter_pos - 1]

    def __repr__(self):
        return "\n".join([str(msg) for msg in self.msgs])

#---------------------------------------------------------------------------
class Notmuch:
#---------------------------------------------------------------------------
    """
    python abstraction to the notmuch command line interface. 
    It uses the logging module for logging, 
    so you can set that up to log to files etc.

    valid instance variables: self.*:
    -logging: a logging instance, e.g. logging.DEBUG
    """
    __notmuchcmd__ = "notmuch"

    def __init__(self, logger=None):
        if logger:
            self.logger = logger
        else:
            self.logger = logging.getLogger()

    def exec_cmd(self, cmdoptions):
        """ Execute a notmuch command and return the 'process'.
        cmdoptions is a list of command options to notmuch. You will 
        usually finish the prosess with something like:
        (stdout, stderr) = prosses.communicate()
        """
        logging.debug("Execute %s" % ([Notmuch.__notmuchcmd__] + cmdoptions))

        prosses = subprocess.Popen([Notmuch.__notmuchcmd__] + cmdoptions, 
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
        return prosses


    def show(self, term):
        """searches notmuch for "term" and returns Messages()"""
        cmdoptions = ['show', term]
        prosses = self.exec_cmd(cmdoptions)
        (stdout, stderr) = prosses.communicate()
        # parse notmuch return and return Message or (Message1, Message2,...)
        #TODO check prosses.returncode
        msgs = Messages(stdout)
        return msgs

    def search(self, term):
        print("Not implemented yet")

    def prune(self, tag="delete", dryrun=False):
        """ Physically delete all mail files matching 'tag'. 
        Returns the number of matched mails.
        If dryrun == True, it will not actually delete them.
        """
        del_msgs = self.show("tag:"+tag)
        len_del_msgs = len(del_msgs)

        if not dryrun:
            deleted = 0
            for m in del_msgs:
                success = self.unlink_file(m)
                deleted += success
            self.logger.info("Deleted %d of %d messages." %
                             (deleted, len_del_msgs))
        else:
            self.logger.info("Would have deleted %d messages." %
                             (len_del_msgs))
        return len_del_msgs

    def unlink_file(self,m):
        """ returns 1 on success, or 0 otherwise.
        Does not fail if the file does not exist."""
        logging.debug("Delete %s" % (m.file))
        try:
            os.unlink(m.file)
        except OSError, e:
            if e.errno == 2:
                logging.info("File %s not found for deletion." % (m.file))
                return 0
            else:
                raise OSError(e)
        return 1


    def syncTags(self,thorough=False, frommaildir=False,dryrun=False, all_mails=None):
        """ sync the unread Tags. It does not really go through all mail files,
        but compares the stored file name with the notmuch tags.
        It will take the maildir tags as authoritative if 'frommaildir' or 
        the notmuch tags otherwise. 
        
        Flags handled:
        * "S": the user has viewed this message. Corresponds to "unread" tag
        Not handled:
        * Flag "P" (passed): the user has resent/forwarded/bounced this message.
        * Flag "R" (replied): the user has replied to this message.
        * Flag "T" (trashed): the user has moved this message to the trash.
        * Flag "D" (draft):
        * Flag "F" (flagged): user-defined flag; toggled at user discretion. 
        """

        now = int(time.time())        
        if not all_mails:
            #search for all messages dating 30 days back and forth in time
            searchterm = "%d..%d" % (now-2592000,now+2592000)
        else:
            searchterm = "0..%d" % (now+2592000)
        msgs = self.show(searchterm)
        tag_trans={'T':'delete'}

        # check all messages for inconsistencies
        num_modified = 0
        for m in msgs:
            modified = False
            # handle SEEN vs unread tags:
            if not (('S' in m.tags) ^ ('unread' in m.notmuchtags)):
                modified = True
                if frommaildir:
                    # Flip the unread notmuch tag
                    m.sync_notmuchtags = m.notmuchtags ^ set(['unread'])
                else:
                    # Flip the SEEN maildir tag
                    m.sync_tags = m.tags ^ set(['S'])

            #handle all other tag consistencies
            #TODO: There might be a shortcut for the common case with set intersections
            #for (k,v) in tag_trans.items():
            #    if ((k in m.tags) ^ (v in m.notmuchtags)):
            #        if frommaildir:
            #            pass
            if modified:
                num_modified += 1 
                m.sync_msg_tags(dryrun=dryrun)

        logging.info("Synced %d messages. %d modified." % (len(msgs), num_modified))


#---------------------------------------------------------------------------
# MAIN
#---------------------------------------------------------------------------
if __name__ == '__main__':
    #set up the logger
    logging.basicConfig(level=logging.INFO,
                        format="%(asctime)s - %(levelname)s - %(message)s",
                        datefmt="%Y%m%d %H:%M:%S")

    notmuch = Notmuch()

    # output help text by default
    if len(sys.argv) == 1:
        sys.argv.append('-h')

    UsageText = """notmuchsync  Copyright (C) 2010 Sebastian Spaeth
This program comes with ABSOLUTELY NO WARRANTY. It is released under the GNU GPL v2.1 (or later).

Usage:
-p --prune\tPrune deleted mails (use --dryrun for no real action)
-s --sync\tSync from notmuch tags to maildir flags.\n\t\tBy default it will only look for mails from the last 30 days.\n\t\tUse --all to look at earlier mails. (probably BUGGY as it reads all mails into RAM)\n\t\tBeware, if timestamps are more than 30 days in the future, we won\'t handle it.
-r --revsync\tSync tags from maildir to notmuch. See also -s.

Options:
-d\t\t Really verbose debug oputput.
-q\t\t Log only errors.
--dryrun\t Do not really modify notmuch db or mail files. Works with -p -r -s commands."""

    #TODO: proper options parsing/handling
    dryrun = '--dryrun' in sys.argv
    all_mails = '--all' in sys.argv
    if '-d' in sys.argv:
        logging.getLogger().setLevel(logging.DEBUG)
    elif '-q' in sys.argv:
        logging.getLogger().setLevel(logging.WARN)

    for arg in sys.argv[1:]:
        if arg in ['-h','--help']:
            print (UsageText)
        elif arg in ['-p','--prune']:
            #prune all mails with a "delete" tag
            notmuch.prune(dryrun=dryrun)
        elif arg in ['-r','--revsync']:
            #synchronize tags in maildir
            notmuch.syncTags(frommaildir=True, dryrun=dryrun, all_mails=all_mails)
        elif arg in ['-s','--sync']:
            #synchronize Unread tags in notmuch
            notmuch.syncTags(frommaildir=False, dryrun=dryrun, all_mails=all_mails)
